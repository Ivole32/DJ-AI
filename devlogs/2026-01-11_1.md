# 2026-01-11 [1]
## ğŸ§  DJ AI â€“ Devlog: Profiles, Playlists & Core Features

In this development phase, DJ AI evolved from a mainly data-driven prototype into a more complete application with real user-facing features. The focus was on building the core functionality needed for users to interact with the system in a meaningful way.

### ğŸ‘¤ User Profiles

A major addition was the implementation of **user profiles**.  
Each user now has an associated profile that includes:

- A profile picture (either a default avatar or a custom uploaded image)
- A short bio
- Profile-related configuration data

This required careful database design as well as handling file uploads securely. I also implemented logic to reset profile pictures back to a default avatar, which helped me better understand how user data and file storage should be managed safely.

### ğŸµ Playlists

Playlists form the backbone of DJ AI and received significant attention during this phase.

Users can now:
- Create and delete playlists
- Set playlists to **public or private**
- Add tracks to playlists in a specific order
- Insert tracks between existing tracks while preserving order

Designing this system pushed me to think more deeply about **PostgreSQL table structures**, ordering strategies, and edge cases such as authorization checks versus non-existent resources.

### ğŸ” Track Handling & Logic

Building playlist logic also meant dealing with real-world data problems.  
Track data needed to be filtered, validated, and consistently structured so that only valid and analyzed tracks were used. Ensuring clean data flow between analysis results and user playlists turned out to be more complex than expected.

### âš ï¸ Challenges

The biggest challenges in this phase were:
- Designing a database schema that supports ordered playlists efficiently
- Handling edge cases in authorization and data consistency
- Properly preparing and filtering analyzed track data so it could be used reliably in playlists

### ğŸ“ What I Learned

Through this phase, I gained valuable experience in:
- Working more deeply with **PostgreSQL**
- Structuring backend code in a scalable and maintainable way
- Understanding how backend logic and frontend requirements influence each other
- Turning abstract data analysis results into usable application features